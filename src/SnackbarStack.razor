@using Soenneker.Quark.Enums.Colors
@using Soenneker.Quark.Snackbars.Enums
@using Soenneker.Quark.Divs
@using Timer = System.Timers.Timer
@inherits Soenneker.Quark.Components.Element

<Div @attributes="BuildAttributes()" >
	<CascadingValue Value="@this" IsFixed="true" >
		@ChildContent
		@foreach (NotificationItem item in notifications)
		{
			<Snackbar @key="@item.Key"
			          Key="@item.Key"
			          Visible="@item.Visible"
			          Color="@item.Color"
			          AutoHideDelay="@(item.HideDelay ?? DefaultDelay)"
			          Closed="@(async (e) => await HandleClosed(e.Key, e.CloseReason))" >
				@if (item.Content != null)
				{
					@item.Content
				}
				else
				{
					@item.Message
				}
			</Snackbar>
		}
	</CascadingValue>
</Div>

@code {
	private readonly List<NotificationItem> notifications = new();
	private readonly Dictionary<string, Timer> autoHideTimers = new();

	[Parameter]
	public SnackbarLocation Position { get; set; } = SnackbarLocation.BottomEnd;

	[Parameter]
	public int DefaultDelay { get; set; } = 5000;

	[Parameter]
	public EventCallback<SnackbarClosedEventArgs> Closed { get; set; }

	protected override Dictionary<string, object> BuildAttributes()
	{
		Dictionary<string, object> attributes = base.BuildAttributes();
		var classes = "snackbar-stack position-fixed p-3";

		classes += Position.Value switch
		{
			"top" => " top-0 start-50 translate-middle-x",
			"top-start" => " top-0 start-0",
			"top-end" => " top-0 end-0",
			"bottom" => " bottom-0 start-50 translate-middle-x",
			"bottom-start" => " bottom-0 start-0",
			"bottom-end" => " bottom-0 end-0",
			_ => " bottom-0 end-0"
		};

		attributes["class"] = AppendToClass(attributes.GetValueOrDefault("class")
			?.ToString(), classes);
		attributes["style"] = "z-index: 1055;";

		return attributes;
	}

    /// <summary>
    /// Pushes the message to the stack to be shown as a snackbar.
    /// </summary>
    /// <param name="message">Message text.</param>
    /// <param name="color">Message color.</param>
    /// <param name="options">Additional message options.</param>
    /// <returns>Returns awaitable task.</returns>
    public async ValueTask Push(string message, Color? color = null, Action<SnackbarOptions>? options = null)
    {
        await Push(message, null, color, options);
    }

    /// <summary>
    /// Pushes custom content to the stack to be shown as a snackbar.
    /// </summary>
    /// <param name="content">Custom content template.</param>
    /// <param name="color">Message color.</param>
    /// <param name="options">Additional message options.</param>
    /// <returns>Returns awaitable task.</returns>
    public async ValueTask Push(RenderFragment content, Color? color = null, Action<SnackbarOptions>? options = null)
    {
        await Push(null, content, color, options);
    }

    /// <summary>
    /// Internal method to push snackbar with either message or content.
    /// </summary>
    private async ValueTask Push(string? message, RenderFragment? content, Color? color, Action<SnackbarOptions>? options)
	{
		var snackbarOptions = new SnackbarOptions();
		options?.Invoke(snackbarOptions);

		var item = new NotificationItem(snackbarOptions.Key ?? Guid.NewGuid()
				.ToString(), message ?? "", null, // No title in simplified version
			color ?? Color.Primary, content, // Use the content template
			false, // No close button in simplified version
			null, // No close text
			false, // No action button in simplified version
			null, // No action text
			snackbarOptions.HideDelay);

		notifications.Add(item);
		await InvokeAsync(StateHasChanged);

		// Set up auto-hide timer if delay is specified
		int delay = item.HideDelay ?? DefaultDelay;
		if (delay > 0)
		{
			var timer = new Timer(delay);
			timer.Elapsed += async (sender, e) =>
			{
				timer.Stop();
				timer.Dispose();
				await HandleClosed(item.Key, SnackbarCloseReason.None);
			};
			timer.Start();
			autoHideTimers[item.Key] = timer;
		}
	}

	private async Task HandleClosed(string key, SnackbarCloseReason reason)
	{
		// Cancel auto-hide timer if it exists
		if (autoHideTimers.TryGetValue(key, out Timer? timer))
		{
			timer.Dispose();
			autoHideTimers.Remove(key);
		}

		notifications.RemoveAll(x => x.Key == key);
		await InvokeAsync(StateHasChanged);
		await Closed.InvokeAsync(new SnackbarClosedEventArgs(key, reason));
	}

	protected override void Dispose(bool disposing)
	{
		foreach (Timer timer in autoHideTimers.Values)
		{
			timer.Dispose();
		}

		autoHideTimers.Clear();
	}
	
}